/* eslint-disable no-redeclare, no-unused-vars */
// This file is generated by `npm run build`.
// remap parameter names from cordova.define
// see `externals` in webpack.cordova.config.js
const cordovaRequire = require;
const cordovaExports = exports;
const cordovaModule = module;
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 759:
/***/ (function(module) {

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

module.exports = function createQRScanner(cordova) {
  var initialStyles = _objectSpread({}, document.body.style);

  var backgroundTransparent = true;
  var backgroundTimeouts = []; // The native implementations should return their status as ['string':'string']
  // dictionaries. Boolean values are encoded to '0' and '1', respectively.

  function stringToBool(string) {
    switch (string) {
      case '1':
        return true;

      case '0':
        return false;

      default:
        throw new Error('QRScanner plugin returned an invalid boolean number-string: ' + string);
    }
  } // Converts the returned ['string':'string'] dictionary to a status object.


  function convertStatus(statusDictionary) {
    return {
      authorized: stringToBool(statusDictionary.authorized),
      denied: stringToBool(statusDictionary.denied),
      restricted: stringToBool(statusDictionary.restricted),
      prepared: stringToBool(statusDictionary.prepared),
      scanning: stringToBool(statusDictionary.scanning),
      previewing: stringToBool(statusDictionary.previewing),
      showing: stringToBool(statusDictionary.showing),
      lightEnabled: stringToBool(statusDictionary.lightEnabled),
      canOpenSettings: stringToBool(statusDictionary.canOpenSettings),
      canEnableLight: stringToBool(statusDictionary.canEnableLight),
      canChangeCamera: stringToBool(statusDictionary.canChangeCamera),
      currentCamera: parseInt(statusDictionary.currentCamera)
    };
  } // Reset body style attribute and clear pending timeouts for omit unexpected style changes.


  function resetBodyStyles() {
    setTimeout(function () {
      backgroundTransparent = false;

      var _iterator = _createForOfIteratorHelper(backgroundTimeouts),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var backgroundTimeout = _step.value;

          if (backgroundTimeout) {
            clearTimeout(backgroundTimeout);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      for (var _i = 0, _Object$keys = Object.keys(document.body.style); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        document.body.style[key] = initialStyles[key] ? initialStyles[key] : '';
      }
    }, 100);
  } // Simple utility method to ensure the background is transparent. Used by the
  // plugin to force re-rendering immediately after the native webview background
  // is made transparent.


  function clearBackground() {
    var body = document.body;

    if (body.style) {
      body.style.backgroundColor = 'rgba(0,0,0,0.01)';
      body.style.backgroundImage = '';

      if (backgroundTransparent) {
        backgroundTimeouts.push(setTimeout(function () {
          body.style.backgroundColor = 'transparent';
        }, 1));
      }

      if (body.parentNode && body.parentNode.style) {
        body.parentNode.style.backgroundColor = 'transparent';
        body.parentNode.style.backgroundImage = '';
      }
    }
  }

  function errorCallback(callback) {
    if (!callback) {
      return null;
    }

    return function (error) {
      var errorCode = parseInt(error);
      var QRScannerError = {};

      switch (errorCode) {
        case 0:
          QRScannerError = {
            name: 'UNEXPECTED_ERROR',
            code: 0,
            _message: 'QRScanner experienced an unexpected error.'
          };
          break;

        case 1:
          QRScannerError = {
            name: 'CAMERA_ACCESS_DENIED',
            code: 1,
            _message: 'The user denied camera access.'
          };
          break;

        case 2:
          QRScannerError = {
            name: 'CAMERA_ACCESS_RESTRICTED',
            code: 2,
            _message: 'Camera access is restricted.'
          };
          break;

        case 3:
          QRScannerError = {
            name: 'BACK_CAMERA_UNAVAILABLE',
            code: 3,
            _message: 'The back camera is unavailable.'
          };
          break;

        case 4:
          QRScannerError = {
            name: 'FRONT_CAMERA_UNAVAILABLE',
            code: 4,
            _message: 'The front camera is unavailable.'
          };
          break;

        case 5:
          QRScannerError = {
            name: 'CAMERA_UNAVAILABLE',
            code: 5,
            _message: 'The camera is unavailable.'
          };
          break;

        case 6:
          QRScannerError = {
            name: 'SCAN_CANCELED',
            code: 6,
            _message: 'Scan was canceled.'
          };
          break;

        case 7:
          QRScannerError = {
            name: 'LIGHT_UNAVAILABLE',
            code: 7,
            _message: 'The device light is unavailable.'
          };
          break;

        case 8:
          // Open settings is only available on iOS 8.0+.
          QRScannerError = {
            name: 'OPEN_SETTINGS_UNAVAILABLE',
            code: 8,
            _message: 'The device is unable to open settings.'
          };
          break;

        default:
          QRScannerError = {
            name: 'UNEXPECTED_ERROR',
            code: 0,
            _message: 'QRScanner returned an invalid error code.'
          };
          break;
      }

      callback(QRScannerError);
    };
  }

  function successCallback(callback) {
    if (!callback) {
      return null;
    }

    return function (statusDict) {
      callback(null, convertStatus(statusDict));
    };
  }

  function doneCallback(callback, clear) {
    if (!callback) {
      return null;
    }

    return function (statusDict) {
      if (clear) {
        clearBackground();
      }

      callback(convertStatus(statusDict));
    };
  }

  return {
    prepare: function prepare(callback, options) {
      backgroundTransparent = true;
      cordova.exec(successCallback(callback), errorCallback(callback), 'QRScanner', 'prepare', options ? [options] : []);
    },
    destroy: function destroy(callback) {
      cordova.exec(doneCallback(callback, true), null, 'QRScanner', 'destroy', []);
      resetBodyStyles();
    },
    scan: function scan(callback, options) {
      if (!callback) {
        throw new Error('No callback provided to scan method.');
      }

      var success = function success(result) {
        // TODO: If there's an error code, then add message.
        callback(null, result);
      };

      cordova.exec(success, errorCallback(callback), 'QRScanner', 'scan', options ? [options] : []);
    },
    cancelScan: function cancelScan(callback) {
      cordova.exec(doneCallback(callback), null, 'QRScanner', 'cancelScan', []);
    },
    show: function show(callback) {
      cordova.exec(doneCallback(callback, true), null, 'QRScanner', 'show', []);
    },
    hide: function hide(callback) {
      cordova.exec(doneCallback(callback, true), null, 'QRScanner', 'hide', []);
    },
    pausePreview: function pausePreview(callback) {
      cordova.exec(doneCallback(callback), null, 'QRScanner', 'pausePreview', []);
    },
    resumePreview: function resumePreview(callback) {
      cordova.exec(doneCallback(callback), null, 'QRScanner', 'resumePreview', []);
    },
    enableLight: function enableLight(callback) {
      cordova.exec(successCallback(callback), errorCallback(callback), 'QRScanner', 'enableLight', []);
    },
    disableLight: function disableLight(callback) {
      cordova.exec(successCallback(callback), errorCallback(callback), 'QRScanner', 'disableLight', []);
    },
    useCamera: function useCamera(index, callback) {
      cordova.exec(successCallback(callback), errorCallback(callback), 'QRScanner', 'useCamera', [index]);
    },
    useFrontCamera: function useFrontCamera(callback) {
      var frontCamera = 1;

      if (callback) {
        this.useCamera(frontCamera, callback);
      } else {
        cordova.exec(null, null, 'QRScanner', 'useCamera', [frontCamera]);
      }
    },
    useBackCamera: function useBackCamera(callback) {
      var backCamera = 0;

      if (callback) {
        this.useCamera(backCamera, callback);
      } else {
        cordova.exec(null, null, 'QRScanner', 'useCamera', [backCamera]);
      }
    },
    openSettings: function openSettings(callback) {
      if (callback) {
        cordova.exec(successCallback(callback), errorCallback(callback), 'QRScanner', 'openSettings', []);
      } else {
        cordova.exec(null, null, 'QRScanner', 'openSettings', []);
      }
    },
    getStatus: function getStatus(callback) {
      if (!callback) {
        throw new Error('No callback provided to getStatus method.');
      }

      cordova.exec(doneCallback(callback), null, 'QRScanner', 'getStatus', []);
    }
  };
};

/***/ }),

/***/ 718:
/***/ (function(module) {

"use strict";
module.exports = cordova;

/***/ }),

/***/ 694:
/***/ (function(module) {

"use strict";
module.exports = cordovaModule;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {
var globalCordova = __webpack_require__(718);

var cordovaModule = __webpack_require__(694);

var createQRScannerAdapter = __webpack_require__(759); // pass in global cordova object to expose cordova.exec


var QRScannerAdapter = createQRScannerAdapter(globalCordova);
cordovaModule.exports = QRScannerAdapter;
}();
/******/ })()
;